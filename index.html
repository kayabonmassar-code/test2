<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spotify Liked Songs Genre Sorter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        spotifyGreen: '#1DB954',
                        spotifyDark: '#191414',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                },
            },
        };
    </script>
    <style>
        body {
            background-color: #0d121c;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Inter', sans-serif;
            color: #e5e7eb;
        }
        .container {
            max-width: 600px;
            width: 95%;
            background-color: #1e293b;
            border-radius: 1rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3), 0 10px 10px -5px rgba(0, 0, 0, 0.1);
        }
        button {
            transition: all 0.3s ease;
        }
        .progress-bar {
            height: 10px;
            background-color: #334155;
            border-radius: 9999px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            width: 0%;
            background-color: #1DB954;
            transition: width 0.5s ease;
        }
        select, input[type="text"] {
            background-color: #334155;
            border: 1px solid #475569;
            color: #e5e7eb;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            width: 100%;
        }
    </style>
</head>
<body>

    <div id="app" class="container p-6 sm:p-8">
        <h1 class="text-3xl font-bold text-center mb-6 flex items-center justify-center text-spotifyGreen">
            <svg class="w-8 h-8 mr-3" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0zm5.727 17.514c-.16.26-.49.348-.75.187-2.618-1.603-5.912-1.954-9.873-1.034-.3.07-.6-.115-.67-.417-.07-.3.115-.6.417-.67 4.31-.99 7.915-.595 10.87 1.258.26.16.348.49.187.75zm1.5-3.32c-.198.318-.606.412-.924.213-3.08-1.9-7.794-2.39-12.72-.942-.35.102-.71-.09-.81-.44-.1-.35.09-.71.44-.81 5.394-1.558 10.51-1.018 13.91 1.096.318.198.412.606.213.924zM7.3 9.492c-2.35 0-3.35-1.002-3.35-3.35S4.95 2.792 7.3 2.792c2.35 0 3.35 1.002 3.35 3.35s-1 3.35-3.35 3.35z"></path>
            </svg>
            Genre Sorter
        </h1>
        <p class="text-center text-slate-400 mb-8">Automatically organize your music into broad, folder-friendly playlists.</p>

        <!-- Dynamic Content Area -->
        <div id="content">
            <!-- Initial View is now hidden by default and acts as a placeholder -->
            <div id="initialView" class="text-center hidden">
                <p class="text-slate-300 mb-6">
                    This tool requires access to your Spotify profile and permission to create new playlists.
                </p>
                <!-- This button is only here for display but is functionally replaced by the immediate display of the link below -->
                <button id="loginButton" class="w-full bg-spotifyGreen text-spotifyDark font-bold py-3 rounded-full shadow-lg">
                    Log in with Spotify
                </button>
            </div>

            <!-- Manual Link Display Area - SHOWN IMMEDIATELY IF NO AUTH CODE -->
            <div id="authLinkContainer" class="p-4 bg-slate-800 rounded-lg hidden">
                <p class="text-yellow-300 font-bold mb-3">Manual Login Required</p>
                <p class="text-sm text-slate-400 mb-3">
                    **Copy this link and paste it into a new browser tab** to log in with Spotify. After login, you'll be redirected back here.
                </p>
                <textarea id="authLink" rows="3" readonly class="w-full p-2 text-sm bg-slate-700 text-slate-200 rounded-md border border-slate-600 cursor-text resize-none"></textarea>
                <button onclick="copyToClipboard()" class="mt-3 w-full bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 rounded-lg">
                    Copy Link
                </button>
            </div>
            
            <!-- Sorting Options Area -->
            <div id="optionsArea" class="mt-4 p-4 bg-slate-800 rounded-lg hidden">
                <h2 class="text-xl font-semibold mb-4 text-spotifyGreen">1. Select Input Source</h2>
                
                <div class="space-y-4">
                    <!-- Source Selection Dropdown -->
                    <div>
                        <label for="sourceSelect" class="block text-sm font-medium text-slate-300 mb-1">Source Type:</label>
                        <select id="sourceSelect" onchange="togglePlaylistInput()">
                            <option value="liked_songs">Liked Songs</option>
                            <option value="playlist">Specific Playlist</option>
                        </select>
                    </div>

                    <!-- Playlist Input Field (Initially Hidden) -->
                    <div id="playlistInputContainer" class="hidden">
                        <label for="playlistInput" class="block text-sm font-medium text-slate-300 mb-1">Playlist URL or ID:</label>
                        <input type="text" id="playlistInput" placeholder="Paste Spotify URL or ID (e.g., 37i9dQZF1DXcBWIGoYBM5M)">
                        <p class="text-xs text-slate-400 mt-1">Example: A link like https://open.spotify.com/playlist/ID</p>
                    </div>
                </div>

                <h2 class="text-xl font-semibold mt-6 mb-4 text-spotifyGreen">2. Start Sorting</h2>
                <button id="sortButton" onclick="startSortingProcess()" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 rounded-lg shadow-lg">
                    Start Genre Sorting
                </button>
            </div>
        </div>

        <!-- Status and Progress Area -->
        <div id="statusArea" class="mt-8 p-4 bg-slate-700 rounded-lg hidden">
            <p id="statusMessage" class="text-lg font-semibold mb-3 text-center"></p>
            <div class="progress-bar">
                <div id="progressBarFill" class="progress-fill"></div>
            </div>
            <p id="subStatus" class="text-sm text-slate-400 mt-2 text-center"></p>

            <div id="results" class="mt-4 max-h-48 overflow-y-auto p-2 bg-slate-800 rounded-lg hidden">
                <h3 class="font-bold text-base text-spotifyGreen mb-1">Playlists Created:</h3>
                <ul id="playlistList" class="text-sm space-y-1"></ul>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const CLIENT_ID = 'fbc4e51a5ad640379aacf6bb8e7a57e2'; 
        const REDIRECT_URI = window.location.href.split('?')[0]; 
        const SCOPES = 'user-library-read playlist-modify-public playlist-modify-private user-read-private playlist-read-private playlist-read-collaborative';
        const AUTH_URL = 'https://accounts.spotify.com/authorize';
        const TOKEN_URL = 'https://accounts.spotify.com/api/token';
        const API_BASE = 'https://api.spotify.com/v1';

        // --- NEW: FOLDER-SPECIFIC GENRE MAPPING (for many small playlists) ---
        // Key: Folder Name Prefix
        // Value: Array of specific Spotify genres to be grouped under that folder
        const FOLDER_PLAYLIST_MAP = {
            'POP & R&B': [
                'pop', 'indie pop', 'dance pop', 'electropop', 'k-pop', 'j-pop', 'alt z', 'bedroom pop', 'boy band', 'girl group', 
                'bubblegum pop', 'pc music', 'trap', 'rap', 'r&b', 'hip hop', 'folk pop', 'soul', 'funk',
                'vocal jazz', 'singer-songwriter', 'country pop', 'alternative r&b', 'neo soul', 'chill pop', 
                'acoustic pop', 'mellow gold', 'indie soul', 'lo-fi beats', 'gospel', 'smooth jazz', 'jazz fusion', 'quiet storm'
            ],
            'ELECTRONIC & DANCE': [
                'electronic', 'edm', 'house', 'techno', 'trance', 'dubstep', 'ambient', 'downtempo', 'glitchcore', 'wave', 'vaporwave', 
                'lo-fi house', 'drum and bass', 'future bass', 'bass music', 'minimal techno', 'progressive house', 'deep house', 
                'chillout', 'trip hop', 'idm', 'electro', 'breakbeat', 'chillwave', 'synth pop', 'dance', 'workout', 'shuffle', 'party', 
                'tropical house', 'uplifting trance', 'eurodance', 'hyperpop', 'digicore', 'bass house'
            ],
            'ROCK & METAL': [
                'modern rock', 'indie rock', 'hard rock', 'classic rock', 'metal', 'heavy metal', 'nu metal', 'symphonic metal', 'power metal', 'grunge', 
                'punk', 'post-punk', 'goth rock', 'shoegaze', 'math rock', 'doom metal', 'black metal', 'death metal', 
                'art rock', 'progressive rock', 'alternative rock', 'glam metal', 'pop punk', 'ska', 'garage rock', 'rockabilly', 'soft rock'
            ],
            'WORLD & LATIN': [ 
                'afrobeat', 'latin', 'cumbia', 'salsa', 'merengue', 'reggae', 'brazilian pop', 'tango', 'world fusion', 
                'kizomba', 'bachata', 'afrobeats', 'flamenco', 'j-rock', 'turkish pop', 'indian pop', 'bollywood', 'indie folk', 'bluegrass', 'celtic'
            ],
            'SOUNDTRACK & EXPERIMENTAL': [
                'experimental', 'noise', 'abstract', 'drone', 'sound art', 'avant-garde', 'glitch', 'free jazz', 
                'industrial', 'minimalism', 'field recording', 'microtonal', 'dark ambient', 'modern classical', 'soundtrack',
                'ambient black metal', 'drone metal', 'opera', 'classical'
            ],
            'RETRO & DECADES': [
                '80s pop', '90s pop', 'disco', 'synthwave', 'new wave', 'new romantic', 
                'yacht rock', 'motown', 'classic soul', 'classic funk', 'classic pop', 'vintage', 'old school', 'rhythm and blues'
            ]
        };

        // --- GLOBAL STATE ---
        let accessToken = '';
        let userId = '';
        const MAX_TRACKS_TO_PROCESS = 3000; 
        const MAX_ARTISTS_PER_BATCH = 50; 
        const MAX_TRACKS_PER_PLAYLIST_ADD = 100;

        // --- UTILITY FUNCTIONS ---

        /** Extracts the ID from a Spotify URL or returns the ID if already provided. */
        function extractIdFromUrl(input) {
            if (!input) return null;
            const match = input.match(/(?:spotify\.com\/(?:user\/\w+\/)?playlist\/|:playlist:)([a-zA-Z0-9]+)/);
            return match ? match[1] : input.trim();
        }

        /** Toggle visibility of the playlist input field. */
        function togglePlaylistInput() {
            const source = document.getElementById('sourceSelect').value;
            document.getElementById('playlistInputContainer').classList.toggle('hidden', source !== 'playlist');
        }
        window.togglePlaylistInput = togglePlaylistInput; 

        /** Converts a string to a safe base64 URL-safe format. */
        function base64UrlEncode(str) {
            return btoa(String.fromCharCode.apply(null, new Uint8Array(str)))
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=/g, '');
        }

        /** Generates a random alphanumeric string for PKCE. */
        function generateRandomString(length) {
            let text = '';
            const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            for (let i = 0; i < length; i++) {
                text += possible.charAt(Math.floor(Math.random() * possible.length));
            }
            return text;
        }

        /** Generates a code challenge from a code verifier using SHA256. */
        async function sha256(v) {
            const encoder = new TextEncoder();
            const data = encoder.encode(v);
            const hash = await window.crypto.subtle.digest('SHA-256', data);
            return new Uint8Array(hash);
        }

        /** Fetches data from Spotify API with built-in access token handling. */
        async function fetchSpotify(url, method = 'GET', body = null) {
            const headers = {
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json',
            };

            const options = {
                method,
                headers,
                body: body ? JSON.stringify(body) : null,
            };

            let response;
            // Implemented exponential backoff for API calls
            let retries = 0;
            const maxRetries = 3;
            const baseDelay = 1000; // 1 second

            while (retries < maxRetries) {
                try {
                    response = await fetch(url, options);
                    if (response.status !== 429) break; // Not rate-limited, proceed

                    // Rate-limited (429), implement backoff
                    retries++;
                    const delay = baseDelay * Math.pow(2, retries - 1) + Math.random() * 1000;
                    console.warn(`Rate limit hit (429). Retrying in ${Math.round(delay / 1000)}s...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                } catch (error) {
                    retries++;
                    if (retries >= maxRetries) throw error;
                    const delay = baseDelay * Math.pow(2, retries - 1) + Math.random() * 1000;
                    console.warn(`Fetch error. Retrying in ${Math.round(delay / 1000)}s...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }


            if (response.ok) {
                const contentType = response.headers.get("content-type");
                if (contentType && contentType.indexOf("application/json") !== -1) {
                    return response.json();
                } else {
                    return {}; // Return empty object for 204 No Content
                }
            } else {
                let errorDetails = `Status ${response.status}: ${response.statusText}`;
                try {
                    const errorJson = await response.json();
                    if (errorJson.error && errorJson.error_description) {
                        errorDetails += ` - ${errorJson.error_description}`;
                    } else if (errorJson.error && errorJson.error.message) {
                         errorDetails += ` - ${errorJson.error.message}`;
                    }
                } catch (e) {
                    // Ignore JSON parsing error
                }
                updateStatus(`Spotify API Error: ${errorDetails}`, 'text-red-400');
                throw new Error(`Spotify API failed: ${errorDetails}`);
            }
        }

        /**
         * NEW LOGIC: Finds all target playlist names ([Folder] - [Genre]) for the given artist genres.
         * This creates many small, highly specific playlists.
         */
        function getPlaylistTargets(genres) {
            const targets = new Set();
            const lowerGenres = genres.map(g => g.toLowerCase());
            const defaultTarget = 'UNCATEGORIZED';
            let foundMatch = false;

            // 1. Check for explicit matches against the FOLDER_PLAYLIST_MAP
            for (const folderPrefix in FOLDER_PLAYLIST_MAP) {
                const folderGenres = FOLDER_PLAYLIST_MAP[folderPrefix];

                for (const artistGenre of lowerGenres) {
                    if (folderGenres.includes(artistGenre)) {
                        // Playlist name is [FOLDER_PREFIX] - Specific Genre (Capitalized)
                        const genreTitle = artistGenre.replace(/\b\w/g, l => l.toUpperCase());
                        targets.add(`[${folderPrefix}] - ${genreTitle}`);
                        foundMatch = true;
                    }
                }
            }

            // 2. Fallback if no match was found
            if (!foundMatch) {
                // If there are genres but they didn't match the map, use the primary genre as a target
                const primaryGenre = lowerGenres.length > 0 ? lowerGenres[0] : 'Unknown';
                const genreTitle = primaryGenre.replace(/\b\w/g, l => l.toUpperCase());
                targets.add(`[${defaultTarget}] - ${genreTitle}`);
            }

            // If an artist has multiple genres, the track will be added to multiple playlists (one for each genre)
            return Array.from(targets);
        }


        // --- UI & STATUS HANDLING ---

        /** Updates the main status message and progress bar. */
        function updateStatus(message, color = 'text-white', percentage = 0, subStatus = '') {
            const statusMessage = document.getElementById('statusMessage');
            const subStatusEl = document.getElementById('subStatus');
            const progressBarFill = document.getElementById('progressBarFill');

            statusMessage.textContent = message;
            statusMessage.style.color = color;

            if (percentage >= 0) {
                document.getElementById('statusArea').classList.remove('hidden');
                progressBarFill.style.width = `${Math.min(100, percentage)}%`;
                subStatusEl.textContent = subStatus;
            } else {
                document.getElementById('statusArea').classList.remove('hidden');
                progressBarFill.style.width = '0%';
                subStatusEl.textContent = '';
            }
        }

        /** Copies the generated link to the clipboard. */
        function copyToClipboard() {
            const linkTextarea = document.getElementById('authLink');
            linkTextarea.select();
            
            try {
                document.execCommand('copy');
                const copyButton = document.querySelector('#authLinkContainer button');
                const originalText = copyButton.textContent;
                copyButton.textContent = "Copied! (Paste in New Tab)";
                setTimeout(() => {
                    copyButton.textContent = originalText;
                }, 3000);
            } catch (err) {
                console.error('Could not copy text: ', err);
                const copyButton = document.querySelector('#authLinkContainer button');
                copyButton.textContent = "Copy Failed - Select Manually!";
            }
        }
        window.copyToClipboard = copyToClipboard; 

        /** Displays the final list of created playlists. */
        function displayResults(playlists) {
            const resultsDiv = document.getElementById('results');
            const playlistList = document.getElementById('playlistList');
            resultsDiv.classList.remove('hidden');
            playlistList.innerHTML = '';

            for (const [playlistName, playlist] of Object.entries(playlists)) {
                if (playlist.trackUris.length > 0) {
                    const li = document.createElement('li');
                    const link = document.createElement('a');
                    link.href = playlist.url;
                    link.target = '_blank';
                    link.classList.add('text-indigo-300', 'hover:text-indigo-400', 'hover:underline', 'font-medium');
                    link.textContent = `‚ñ∂Ô∏è ${playlistName} (${playlist.trackUris.length} tracks)`;
                    li.appendChild(link);
                    playlistList.appendChild(li);
                }
            }
        }

        // --- AUTHENTICATION FLOW (PKCE) ---

        /** Generates and displays the Spotify login link for manual copy/paste. */
        async function redirectToSpotifyAuth() {
            console.log("Starting manual auth link generation...");
            updateStatus("Generating secure login link...", 'text-yellow-400', 0);

            if (!REDIRECT_URI) {
                updateStatus("üö® Setup Error: Could not determine the REDIRECT_URI.", 'text-red-400');
                return;
            }

            const codeVerifier = generateRandomString(128);
            const hashed = await sha256(codeVerifier);
            const codeChallenge = base64UrlEncode(hashed);

            localStorage.setItem('spotify_code_verifier', codeVerifier);

            const params = new URLSearchParams({
                response_type: 'code',
                client_id: CLIENT_ID,
                scope: SCOPES,
                redirect_uri: REDIRECT_URI,
                code_challenge_method: 'S256',
                code_challenge: codeChallenge,
            });

            const redirectUrl = `${AUTH_URL}?${params.toString()}`;
            
            // Show the manual link container and populate the link
            document.getElementById('authLinkContainer').classList.remove('hidden');
            document.getElementById('authLink').value = redirectUrl;
            
            // Update status with instructions
            updateStatus("Login link generated. Please copy and paste the link below.", 'text-yellow-300', 10); 
            console.log("Manual Auth Link Generated.");
        }

        /** Exchanges the authorization code for an access token. */
        async function exchangeCodeForToken(code) {
            const codeVerifier = localStorage.getItem('spotify_code_verifier');
            if (!codeVerifier) {
                updateStatus("Authentication Failed: Code verifier missing. Try logging in again.", 'text-red-400');
                return;
            }
            localStorage.removeItem('spotify_code_verifier');

            const params = new URLSearchParams({
                client_id: CLIENT_ID,
                grant_type: 'authorization_code',
                code: code,
                redirect_uri: REDIRECT_URI,
                code_verifier: codeVerifier,
            });

            const options = {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: params,
            };

            try {
                updateStatus("Authenticating...", 'text-yellow-400', 5);
                const response = await fetch(TOKEN_URL, options);
                const data = await response.json();

                if (response.ok) {
                    accessToken = data.access_token;
                    // Show the options area now
                    document.getElementById('optionsArea').classList.remove('hidden');
                    updateStatus("Authentication successful! Ready to sort.", 'text-spotifyGreen', 10);
                } else {
                    updateStatus(`Authentication Error: ${data.error_description || data.error}`, 'text-red-400');
                }
            } catch (error) {
                updateStatus("Authentication Network Error. Check connection.", 'text-red-400');
            }
        }
        
        // --- CORE FETCH LOGIC ---

        /** Gets the current user's ID. */
        async function getCurrentUser() {
            updateStatus("Fetching user profile...", 'text-white', 10);
            const user = await fetchSpotify(`${API_BASE}/me`);
            userId = user.id;
        }

        /** Fetches all liked tracks for the user. */
        async function fetchAllLikedTracks() {
            let tracks = [];
            let url = `${API_BASE}/me/tracks?limit=50`;
            let total = 1; 
            let offset = 0;

            while (offset < total && offset < MAX_TRACKS_TO_PROCESS) {
                updateStatus("Fetching liked songs...", 'text-white', 15 + (offset / Math.min(total, MAX_TRACKS_TO_PROCESS)) * 15, `Fetched ${offset} of ${total} tracks...`);

                const response = await fetchSpotify(url);
                total = response.total;
                
                response.items.forEach(item => {
                    if (item.track && item.track.uri && item.track.artists.length > 0) {
                        tracks.push({
                            id: item.track.id,
                            uri: item.track.uri,
                            name: item.track.name,
                            artistId: item.track.artists[0].id
                        });
                    }
                });

                offset += response.items.length;
                url = response.next;
                
                if (!url || offset >= MAX_TRACKS_TO_PROCESS) {
                    break;
                }
            }

            updateStatus(`Fetched all tracks. Total: ${tracks.length}.`, 'text-white', 30);
            return tracks;
        }
        
        /** Fetches all tracks from a specific playlist ID. */
        async function fetchPlaylistTracks(playlistId) {
            let tracks = [];
            let url = `${API_BASE}/playlists/${playlistId}/tracks?limit=50&fields=total,next,items(track(id,uri,name,artists(id)))`;
            let total = 1; 
            let offset = 0;

            while (offset < total && offset < MAX_TRACKS_TO_PROCESS) {
                updateStatus("Fetching playlist tracks...", 'text-white', 15 + (offset / Math.min(total, MAX_TRACKS_TO_PROCESS)) * 15, `Fetched ${offset} of ${total} tracks...`);

                const response = await fetchSpotify(url);
                total = response.total;
                
                response.items.forEach(item => {
                    if (item.track && item.track.id && item.track.artists.length > 0) {
                        tracks.push({
                            id: item.track.id,
                            uri: item.track.uri,
                            name: item.track.name,
                            artistId: item.track.artists[0].id
                        });
                    }
                });

                offset += response.items.length;
                url = response.next;
                
                if (!url || offset >= MAX_TRACKS_TO_PROCESS) {
                    break;
                }
            }

            updateStatus(`Fetched all tracks. Total: ${tracks.length}.`, 'text-white', 30);
            return tracks;
        }


        /** Fetches genres for a list of artist IDs. */
        async function fetchArtistGenres(artistIds) {
            const genreMap = {};
            const batches = [];
            
            // Batch artists into groups of 50 (API limit)
            for (let i = 0; i < artistIds.length; i += MAX_ARTISTS_PER_BATCH) {
                batches.push(artistIds.slice(i, i + MAX_ARTISTS_PER_BATCH));
            }

            for (let i = 0; i < batches.length; i++) {
                const batch = batches[i];
                const ids = batch.join(',');
                const url = `${API_BASE}/artists?ids=${ids}`;

                const percentage = 30 + ((i + 1) / batches.length) * 30;
                updateStatus("Analyzing song genres...", 'text-white', percentage, `Processing batch ${i + 1} of ${batches.length} artists...`);

                const response = await fetchSpotify(url);
                if (response.artists) {
                    response.artists.forEach(artist => {
                        if (artist && artist.id) {
                            genreMap[artist.id] = artist.genres || [];
                        }
                    });
                }
            }

            return genreMap;
        }

        /** Creates a new public playlist with the provided name. */
        async function createPlaylist(playlistName, description) {
            const body = {
                name: playlistName, 
                description: description,
                public: true, 
            };

            const response = await fetchSpotify(`${API_BASE}/users/${userId}/playlists`, 'POST', body);
            return {
                id: response.id,
                url: response.external_urls.spotify,
                snapshot_id: response.snapshot_id
            };
        }

        /** Adds tracks to an existing playlist. */
        async function addTracksToPlaylist(playlistId, trackUris) {
            for (let i = 0; i < trackUris.length; i += MAX_TRACKS_PER_PLAYLIST_ADD) {
                const batch = trackUris.slice(i, i + MAX_TRACKS_PER_PLAYLIST_ADD);
                const body = { uris: batch };

                await fetchSpotify(`${API_BASE}/playlists/${playlistId}/tracks`, 'POST', body);
            }
        }

        /** Main orchestration function. */
        async function startSortingProcess() {
            try {
                // Disable button during process
                document.getElementById('sortButton').disabled = true;

                // 1. Get User ID
                await getCurrentUser();

                // 2. Fetch Source Tracks
                const source = document.getElementById('sourceSelect').value;
                let tracks = [];
                let playlistTitle = "Liked Songs";

                if (source === 'liked_songs') {
                    tracks = await fetchAllLikedTracks();
                } else if (source === 'playlist') {
                    const input = document.getElementById('playlistInput').value;
                    const playlistId = extractIdFromUrl(input);

                    if (!playlistId) {
                        updateStatus("Error: Please enter a valid Playlist URL or ID.", 'text-red-400', 0);
                        return;
                    }
                    tracks = await fetchPlaylistTracks(playlistId);
                    
                    try {
                        const playlistDetails = await fetchSpotify(`${API_BASE}/playlists/${playlistId}?fields=name`);
                        playlistTitle = playlistDetails.name;
                    } catch (e) {
                        console.warn("Could not fetch playlist name, using default.");
                    }
                }

                if (tracks.length === 0) {
                    updateStatus(`No tracks found in the selected source (${playlistTitle}).`, 'text-yellow-400', 100);
                    document.getElementById('sortButton').disabled = false;
                    return;
                }

                // 3. Get unique Artist IDs
                const uniqueArtistIds = Array.from(new Set(tracks.map(t => t.artistId))).filter(id => id);

                // 4. Fetch Genres for all Artists
                const artistGenreMap = await fetchArtistGenres(uniqueArtistIds);

                // 5. Sort Tracks by specific Genre (many small playlists)
                // Structure: { '[Folder Prefix] - [Specific Genre]': [trackUris] } 
                const playlistTrackMap = {}; 

                tracks.forEach(track => {
                    const genres = artistGenreMap[track.artistId] || [];
                    
                    // Get all target playlist names for this track
                    const targetPlaylistNames = getPlaylistTargets(genres); 

                    targetPlaylistNames.forEach(playlistName => {
                        if (!playlistTrackMap[playlistName]) {
                           playlistTrackMap[playlistName] = [];
                        }
                        // Add track only if not already present (prevents duplicates if an artist has multiple matching genres)
                        if (!playlistTrackMap[playlistName].includes(track.uri)) {
                           playlistTrackMap[playlistName].push(track.uri);
                        }
                    });
                });

                // Filter out playlists that ended up empty
                const activePlaylists = Object.entries(playlistTrackMap).filter(([, uris]) => uris.length > 0);
                const estimatedTotalPlaylists = activePlaylists.length;

                updateStatus(`Sorting complete. Found ${estimatedTotalPlaylists} specific genre playlists to create.`, 'text-white', 65);

                // 6. Create Playlists and Add Tracks
                const playlistMap = {};
                let playlistCount = 0;

                for (const [newPlaylistName, trackUris] of activePlaylists) {
                    playlistCount++;
                    
                    // The playlist name is already formatted as '[FOLDER] - [GENRE]'
                    
                    const percentage = 65 + (playlistCount / estimatedTotalPlaylists) * 35;
                    updateStatus(
                        "Creating and populating playlists...", 
                        'text-white', 
                        percentage, 
                        `Processing Playlist: ${newPlaylistName} (${trackUris.length} tracks) - ${playlistCount}/${estimatedTotalPlaylists}`
                    );

                    // Extract the specific genre name for the description
                    const specificGenre = newPlaylistName.replace(/^\[.*?\]\s*-\s*/, '');
                    
                    // A. Create Playlist 
                    const description = `Tracks categorized as ${specificGenre.toLowerCase()}, sourced from your ${playlistTitle}.`;
                    const newPlaylist = await createPlaylist(newPlaylistName, description);

                    // B. Add Tracks to Playlist
                    await addTracksToPlaylist(newPlaylist.id, trackUris);
                    
                    playlistMap[newPlaylistName] = {
                        url: newPlaylist.url,
                        trackUris: trackUris
                    };
                }

                updateStatus("‚úÖ All genre-specific playlists created successfully!", 'text-spotifyGreen', 100, `You created ${estimatedTotalPlaylists} playlists. Look for them in your Spotify library!`);
                displayResults(playlistMap);

            } catch (error) {
                console.error("Critical Sorting Error:", error);
                if (document.getElementById('statusMessage').style.color !== 'red') {
                    updateStatus("A critical error occurred during the process. See console for details.", 'text-red-400', 100);
                }
            } finally {
                document.getElementById('sortButton').disabled = false;
            }
        }
        window.startSortingProcess = startSortingProcess; 

        // --- INITIALIZATION AND ROUTER ---

        /** Main entry point to check for auth code and start process. */
        function initializeApp() {
            const params = new URLSearchParams(window.location.search);
            const code = params.get('code');

            if (accessToken) {
                // If token exists (shouldn't happen in this sandbox, but check anyway)
                document.getElementById('optionsArea').classList.remove('hidden');
                updateStatus("Authentication successful! Ready to sort.", 'text-spotifyGreen', 10);
            } else if (code) {
                // Code received: start auth flow
                document.getElementById('initialView').classList.add('hidden');
                document.getElementById('authLinkContainer').classList.add('hidden');
                document.getElementById('statusArea').classList.remove('hidden');
                
                window.history.pushState({}, document.title, REDIRECT_URI);
                exchangeCodeForToken(code);
            } else {
                // Show the manual link immediately (since automatic redirect fails here)
                redirectToSpotifyAuth();
            }
        }

        initializeApp(); 
    </script>
</body>
</html>
