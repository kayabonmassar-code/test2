<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spotify Liked Songs Genre Sorter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        spotifyGreen: '#1DB954',
                        spotifyDark: '#191414',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                },
            },
        };
    </script>
    <style>
        body {
            background-color: #0d121c;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Inter', sans-serif;
            color: #e5e7eb;
        }
        .container {
            max-width: 600px;
            width: 95%;
            background-color: #1e293b;
            border-radius: 1rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3), 0 10px 10px -5px rgba(0, 0, 0, 0.1);
        }
        button {
            transition: all 0.3s ease;
        }
        .progress-bar {
            height: 10px;
            background-color: #334155;
            border-radius: 9999px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            width: 0%;
            background-color: #1DB954;
            transition: width 0.5s ease;
        }
        select, input[type="text"] {
            background-color: #334155;
            border: 1px solid #475569;
            color: #e5e7eb;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            width: 100%;
        }
    </style>
</head>
<body>

    <div id="app" class="container p-6 sm:p-8">
        <h1 class="text-3xl font-bold text-center mb-6 flex items-center justify-center text-spotifyGreen">
            <svg class="w-8 h-8 mr-3" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0zm5.727 17.514c-.16.26-.49.348-.75.187-2.618-1.603-5.912-1.954-9.873-1.034-.3.07-.6-.115-.67-.417-.07-.3.115-.6.417-.67 4.31-.99 7.915-.595 10.87 1.258.26.16.348.49.187.75zm1.5-3.32c-.198.318-.606.412-.924.213-3.08-1.9-7.794-2.39-12.72-.942-.35.102-.71-.09-.81-.44-.1-.35.09-.71.44-.81 5.394-1.558 10.51-1.018 13.91 1.096.318.198.412.606.213.924zM7.3 9.492c-2.35 0-3.35-1.002-3.35-3.35S4.95 2.792 7.3 2.792c2.35 0 3.35 1.002 3.35 3.35s-1 3.35-3.35 3.35z"></path>
            </svg>
            Genre Sorter
        </h1>
        <p class="text-center text-slate-400 mb-8">Automatically organize your music into broad, folder-friendly playlists.</p>

        <!-- Dynamic Content Area -->
        <div id="content">
            <div id="initialView" class="text-center">
                <p class="text-slate-300 mb-6">
                    This tool requires access to your Spotify profile and permission to create new playlists.
                </p>
                <button id="loginButton" class="w-full bg-spotifyGreen hover:bg-green-600 text-spotifyDark font-bold py-3 rounded-full shadow-lg hover:shadow-xl transform hover:scale-105">
                    Log in with Spotify
                </button>
            </div>

            <!-- New Link Display Area -->
            <div id="authLinkContainer" class="p-4 bg-slate-800 rounded-lg hidden">
                <p class="text-yellow-300 font-bold mb-3">Manual Login Required</p>
                <p class="text-sm text-slate-400 mb-3">
                    Copy the link below and paste it into a new browser tab to log in with Spotify. After login, you'll be redirected back to this page.
                </p>
                <textarea id="authLink" rows="3" readonly class="w-full p-2 text-sm bg-slate-700 text-slate-200 rounded-md border border-slate-600 cursor-text resize-none"></textarea>
                <button onclick="copyToClipboard()" class="mt-3 w-full bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 rounded-lg">
                    Copy Link
                </button>
            </div>
            
            <!-- Sorting Options Area -->
            <div id="optionsArea" class="mt-4 p-4 bg-slate-800 rounded-lg hidden">
                <h2 class="text-xl font-semibold mb-4 text-spotifyGreen">1. Select Input Source</h2>
                
                <div class="space-y-4">
                    <!-- Source Selection Dropdown -->
                    <div>
                        <label for="sourceSelect" class="block text-sm font-medium text-slate-300 mb-1">Source Type:</label>
                        <select id="sourceSelect" onchange="togglePlaylistInput()">
                            <option value="liked_songs">Liked Songs</option>
                            <option value="playlist">Specific Playlist</option>
                        </select>
                    </div>

                    <!-- Playlist Input Field (Initially Hidden) -->
                    <div id="playlistInputContainer" class="hidden">
                        <label for="playlistInput" class="block text-sm font-medium text-slate-300 mb-1">Playlist URL or ID:</label>
                        <input type="text" id="playlistInput" placeholder="Paste Spotify URL or ID (e.g., 37i9dQZF1DXcBWIGoYBM5M)">
                        <p class="text-xs text-slate-400 mt-1">Example: A link like https://open.spotify.com/playlist/ID</p>
                    </div>
                </div>

                <h2 class="text-xl font-semibold mt-6 mb-4 text-spotifyGreen">2. Start Sorting</h2>
                <button id="sortButton" onclick="startSortingProcess()" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 rounded-lg shadow-lg">
                    Start Genre Sorting
                </button>
            </div>
        </div>

        <!-- Status and Progress Area -->
        <div id="statusArea" class="mt-8 p-4 bg-slate-700 rounded-lg hidden">
            <p id="statusMessage" class="text-lg font-semibold mb-3 text-center"></p>
            <div class="progress-bar">
                <div id="progressBarFill" class="progress-fill"></div>
            </div>
            <p id="subStatus" class="text-sm text-slate-400 mt-2 text-center"></p>

            <div id="results" class="mt-4 max-h-48 overflow-y-auto p-2 bg-slate-800 rounded-lg hidden">
                <h3 class="font-bold text-base text-spotifyGreen mb-1">Playlists Created:</h3>
                <ul id="playlistList" class="text-sm space-y-1"></ul>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        // NOTE: The Client ID is provided for the functionality but would typically be hidden in a real application.
        const CLIENT_ID = 'fbc4e51a5ad640379aacf6bb8e7a57e2'; 
        const REDIRECT_URI = window.location.href.split('?')[0]; 
        // NEW SCOPES: Added playlist-read-private/collaborative for reading tracks from custom playlists
        const SCOPES = 'user-library-read playlist-modify-public playlist-modify-private user-read-private playlist-read-private playlist-read-collaborative';
        const AUTH_URL = 'https://accounts.spotify.com/authorize';
        const TOKEN_URL = 'https://accounts.spotify.com/api/token';
        const API_BASE = 'https://api.spotify.com/v1';

        // --- NEW: GENRE CATEGORY MAPPING (Wider Categories) ---
        // Significantly expanded and consolidated to ensure minimal 'unsorted' tracks.
        const GENRE_CATEGORY_MAP = {
            'Pop/R&B': [
                'pop', 'indie pop', 'dance pop', 'electropop', 'k-pop', 'j-pop', 'alt z', 'bedroom pop', 'boy band', 'girl group', 
                'bubblegum pop', 'pc music', 'trap', 'rap', 'r&b', 'hip hop', 'folk pop', 'soul', 'funk',
                'vocal jazz', 'singer-songwriter', 'country pop', 'alternative r&b', 'neo soul', 'chill pop', 
                'acoustic pop', 'mellow gold', 'indie soul', 'lo-fi beats', 'gospel' 
            ],
            'Electronic/Dance': [
                'electronic', 'edm', 'house', 'techno', 'trance', 'dubstep', 'ambient', 'downtempo', 'glitchcore', 'wave', 'vaporwave', 
                'lo-fi house', 'drum and bass', 'future bass', 'bass music', 'minimal techno', 'progressive house', 'deep house', 
                'chillout', 'trip hop', 'idm', 'electro', 'breakbeat', 'chillwave', 'synth pop', 'dance', 'workout', 'shuffle', 'party', 
                'tropical house', 'uplifting trance', 'eurodance'
            ],
            'Rock/Metal': [
                'modern rock', 'indie rock', 'hard rock', 'classic rock', 'metal', 'heavy metal', 'nu metal', 'symphonic metal', 'power metal', 'grunge', 
                'punk', 'post-punk', 'goth rock', 'shoegaze', 'math rock', 'doom metal', 'black metal', 'death metal', 
                'art rock', 'progressive rock', 'alternative rock', 'glam metal', 'pop punk', 'ska', 'garage rock'
            ],
            'Experimental/Abstract': [
                'experimental', 'noise', 'abstract', 'drone', 'sound art', 'avant-garde', 'glitch', 'free jazz', 
                'industrial', 'minimalism', 'field recording', 'microtonal', 'dark ambient', 'modern classical', 'soundtrack',
                'ambient black metal', 'drone metal'
            ],
            'Retro/Decades': [ 
                '80s pop', '90s pop', 'disco', 'synthwave', 'new wave', 'new romantic', 
                'yacht rock', 'motown', 'classic soul', 'classic funk', 'classic pop', 'vintage', 'old school', 'rockabilly', 
                'soft rock', 'rhythm and blues'
            ],
            'World/Latin': [ 
                'afrobeat', 'latin', 'cumbia', 'salsa', 'merengue', 'reggae', 'brazilian pop', 'tango', 'world fusion', 
                'kizomba', 'bachata', 'afrobeats', 'flamenco', 'j-rock', 'turkish pop', 'indian pop', 'bollywood', 'indie folk', 'bluegrass'
            ],
            'Hyperpop': [ // Kept separate as it's a niche, easily defined modern genre
                'hyperpop', 'digicore', 'pc music', 'bubblegum pop', 'glitchcore', 'drain'
            ],
        };

        // --- GLOBAL STATE ---
        let accessToken = '';
        let userId = '';
        // Increased limit for better sorting coverage
        const MAX_TRACKS_TO_PROCESS = 3000; 
        const MAX_ARTISTS_PER_BATCH = 50; 
        const MAX_TRACKS_PER_PLAYLIST_ADD = 100;

        // --- UTILITY FUNCTIONS ---

        /** Extracts the ID from a Spotify URL or returns the ID if already provided. */
        function extractIdFromUrl(input) {
            if (!input) return null;
            const match = input.match(/(?:spotify\.com\/(?:user\/\w+\/)?playlist\/|:playlist:)([a-zA-Z0-9]+)/);
            return match ? match[1] : input.trim();
        }

        /** Toggle visibility of the playlist input field. */
        function togglePlaylistInput() {
            const source = document.getElementById('sourceSelect').value;
            document.getElementById('playlistInputContainer').classList.toggle('hidden', source !== 'playlist');
        }
        window.togglePlaylistInput = togglePlaylistInput; // Expose to global scope for onchange

        /** Converts a string to a safe base64 URL-safe format. */
        function base64UrlEncode(str) {
            return btoa(String.fromCharCode.apply(null, new Uint8Array(str)))
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=/g, '');
        }

        /** Generates a random alphanumeric string for PKCE. */
        function generateRandomString(length) {
            let text = '';
            const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            for (let i = 0; i < length; i++) {
                text += possible.charAt(Math.floor(Math.random() * possible.length));
            }
            return text;
        }

        /** Generates a code challenge from a code verifier using SHA256. */
        async function sha256(v) {
            const encoder = new TextEncoder();
            const data = encoder.encode(v);
            const hash = await window.crypto.subtle.digest('SHA-256', data);
            return new Uint8Array(hash);
        }

        /** Fetches data from Spotify API with built-in access token handling. */
        async function fetchSpotify(url, method = 'GET', body = null) {
            const headers = {
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json',
            };

            const options = {
                method,
                headers,
                body: body ? JSON.stringify(body) : null,
            };

            let response;
            try {
                response = await fetch(url, options);
            } catch (error) {
                console.error("Fetch error:", error);
                updateStatus(`Connection Error: ${error.message}`, 'red');
                throw new Error("Network connection failed.");
            }

            if (response.ok) {
                const contentType = response.headers.get("content-type");
                if (contentType && contentType.indexOf("application/json") !== -1) {
                    return response.json();
                } else {
                    return {}; // Return empty object for 204 No Content
                }
            } else {
                let errorDetails = `Status ${response.status}: ${response.statusText}`;
                try {
                    const errorJson = await response.json();
                    if (errorJson.error && errorJson.error_description) {
                        errorDetails += ` - ${errorJson.error_description}`;
                    } else if (errorJson.error && errorJson.error.message) {
                         errorDetails += ` - ${errorJson.error.message}`;
                    }
                } catch (e) {
                    // Ignore JSON parsing error
                }
                updateStatus(`Spotify API Error: ${errorDetails}`, 'text-red-400');
                throw new Error(`Spotify API failed: ${errorDetails}`);
            }
        }

        /**
         * Maps a Spotify genre to one of the defined folder categories.
         * Returns null if no explicit match is found.
         */
        function mapGenreToCategory(spotifyGenre) {
            const lowerGenre = spotifyGenre.toLowerCase();
            for (const category in GENRE_CATEGORY_MAP) {
                // Check if the Spotify genre is explicitly listed in a category
                if (GENRE_CATEGORY_MAP[category].includes(lowerGenre)) {
                    return category;
                }
            }
            return null; // Return null if no explicit match
        }

        /**
         * Tries to find the closest category based on genre keywords if no explicit match is found.
         */
        function findClosestCategory(genres) {
            const genreKeywords = {
                'Rock/Metal': ['rock', 'metal', 'punk', 'grunge', 'shoegaze', 'glam'],
                'Electronic/Dance': ['dance', 'house', 'techno', 'trance', 'edm', 'dubstep', 'bass', 'electro'],
                'World/Latin': ['latin', 'world', 'salsa', 'reggae', 'afro', 'cumbia', 'brazilian', 'tango', 'flamenco'],
                'Retro/Decades': ['80s', '90s', 'classic', 'vintage', 'disco', 'motown', 'soft rock'],
                'Experimental/Abstract': ['experimental', 'noise', 'drone', 'ambient', 'abstract', 'industrial', 'avant-garde', 'glitch'],
                'Hyperpop': ['hyperpop', 'digicore', 'glitchcore'],
                'Pop/R&B': ['pop', 'r&b', 'soul', 'hip hop', 'funk', 'rap', 'singer-songwriter', 'acoustic', 'chill', 'lo-fi'],
            };

            for (const genre of genres) {
                const lowerGenre = genre.toLowerCase();
                for (const category in genreKeywords) {
                    if (genreKeywords[category].some(keyword => lowerGenre.includes(keyword))) {
                        return category;
                    }
                }
            }

            // Final safety net if nothing matches - defaults to the largest category
            return 'Pop/R&B'; 
        }

        // --- UI & STATUS HANDLING ---

        /** Updates the main status message and progress bar. */
        function updateStatus(message, color = 'text-white', percentage = 0, subStatus = '') {
            const statusMessage = document.getElementById('statusMessage');
            const subStatusEl = document.getElementById('subStatus');
            const progressBarFill = document.getElementById('progressBarFill');

            statusMessage.textContent = message;
            statusMessage.style.color = color;

            if (percentage >= 0) {
                document.getElementById('statusArea').classList.remove('hidden');
                progressBarFill.style.width = `${Math.min(100, percentage)}%`;
                subStatusEl.textContent = subStatus;
            } else {
                document.getElementById('statusArea').classList.remove('hidden');
                progressBarFill.style.width = '0%';
                subStatusEl.textContent = '';
            }
        }

        /** Copies the generated link to the clipboard. */
        function copyToClipboard() {
            const linkTextarea = document.getElementById('authLink');
            linkTextarea.select();
            
            try {
                document.execCommand('copy');
                const copyButton = document.querySelector('#authLinkContainer button');
                const originalText = copyButton.textContent;
                copyButton.textContent = "Copied! (Paste in New Tab)";
                setTimeout(() => {
                    copyButton.textContent = originalText;
                }, 3000);
            } catch (err) {
                console.error('Could not copy text: ', err);
                const copyButton = document.querySelector('#authLinkContainer button');
                copyButton.textContent = "Copy Failed - Select Manually!";
            }
        }
        window.copyToClipboard = copyToClipboard; // Expose to global scope for onclick

        /** Displays the final list of created playlists. */
        function displayResults(playlists) {
            const resultsDiv = document.getElementById('results');
            const playlistList = document.getElementById('playlistList');
            resultsDiv.classList.remove('hidden');
            playlistList.innerHTML = '';

            for (const [playlistName, playlist] of Object.entries(playlists)) {
                if (playlist.trackUris.length > 0) {
                    const li = document.createElement('li');
                    const link = document.createElement('a');
                    link.href = playlist.url;
                    link.target = '_blank';
                    link.classList.add('text-indigo-300', 'hover:text-indigo-400', 'hover:underline', 'font-medium');
                    link.textContent = `‚ñ∂Ô∏è ${playlistName} (${playlist.trackUris.length} tracks)`;
                    li.appendChild(link);
                    playlistList.appendChild(li);
                }
            }
        }

        // --- AUTHENTICATION FLOW (PKCE) ---

        /** Generates and displays the Spotify login link for manual copy/paste. */
        async function redirectToSpotifyAuth() {
            console.log("Login button clicked. Starting manual auth link generation...");
            updateStatus("Generating secure login link...", 'text-yellow-400', 0); // Provide immediate feedback

            if (!REDIRECT_URI) {
                updateStatus("üö® Setup Error: Could not determine the REDIRECT_URI.", 'text-red-400');
                return;
            }

            // PKCE setup (asynchronous hashing required)
            const codeVerifier = generateRandomString(128);
            const hashed = await sha256(codeVerifier);
            const codeChallenge = base64UrlEncode(hashed);

            localStorage.setItem('spotify_code_verifier', codeVerifier);

            const params = new URLSearchParams({
                response_type: 'code',
                client_id: CLIENT_ID,
                scope: SCOPES,
                redirect_uri: REDIRECT_URI,
                code_challenge_method: 'S256',
                code_challenge: codeChallenge,
            });

            const redirectUrl = `${AUTH_URL}?${params.toString()}`;
            
            // Show the manual link container and populate the link
            document.getElementById('initialView').classList.add('hidden');
            document.getElementById('authLinkContainer').classList.remove('hidden');
            document.getElementById('authLink').value = redirectUrl;
            
            // Update status with instructions
            updateStatus("Login link generated. Please copy and paste the link below.", 'text-yellow-300', 10); 
            console.log("Manual Auth Link Generated.");
        }

        /** Exchanges the authorization code for an access token. */
        async function exchangeCodeForToken(code) {
            const codeVerifier = localStorage.getItem('spotify_code_verifier');
            if (!codeVerifier) {
                updateStatus("Authentication Failed: Code verifier missing. Try logging in again.", 'text-red-400');
                return;
            }
            localStorage.removeItem('spotify_code_verifier');

            const params = new URLSearchParams({
                client_id: CLIENT_ID,
                grant_type: 'authorization_code',
                code: code,
                redirect_uri: REDIRECT_URI,
                code_verifier: codeVerifier,
            });

            const options = {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: params,
            };

            try {
                updateStatus("Authenticating...", 'text-yellow-400', 5);
                const response = await fetch(TOKEN_URL, options);
                const data = await response.json();

                if (response.ok) {
                    accessToken = data.access_token;
                    // Show the options area now
                    document.getElementById('optionsArea').classList.remove('hidden');
                    updateStatus("Authentication successful! Ready to sort.", 'text-spotifyGreen', 10);
                } else {
                    updateStatus(`Authentication Error: ${data.error_description || data.error}`, 'text-red-400');
                }
            } catch (error) {
                updateStatus("Authentication Network Error. Check connection.", 'text-red-400');
            }
        }
        
        // --- CORE FETCH LOGIC ---

        /** Gets the current user's ID. */
        async function getCurrentUser() {
            updateStatus("Fetching user profile...", 'text-white', 10);
            const user = await fetchSpotify(`${API_BASE}/me`);
            userId = user.id;
        }

        /** Fetches all liked tracks for the user. */
        async function fetchAllLikedTracks() {
            let tracks = [];
            let url = `${API_BASE}/me/tracks?limit=50`;
            let total = 1; 
            let offset = 0;

            while (offset < total && offset < MAX_TRACKS_TO_PROCESS) {
                updateStatus("Fetching liked songs...", 'text-white', 15 + (offset / Math.min(total, MAX_TRACKS_TO_PROCESS)) * 15, `Fetched ${offset} of ${total} tracks...`);

                const response = await fetchSpotify(url);
                total = response.total;
                
                response.items.forEach(item => {
                    if (item.track && item.track.uri && item.track.artists.length > 0) {
                        tracks.push({
                            id: item.track.id,
                            uri: item.track.uri,
                            name: item.track.name,
                            artistId: item.track.artists[0].id
                        });
                    }
                });

                offset += response.items.length;
                url = response.next;
                
                if (!url || offset >= MAX_TRACKS_TO_PROCESS) {
                    break;
                }
            }

            updateStatus(`Fetched all tracks. Total: ${tracks.length}.`, 'text-white', 30);
            return tracks;
        }
        
        /** NEW: Fetches all tracks from a specific playlist ID. */
        async function fetchPlaylistTracks(playlistId) {
            let tracks = [];
            let url = `${API_BASE}/playlists/${playlistId}/tracks?limit=50&fields=total,next,items(track(id,uri,name,artists(id)))`;
            let total = 1; 
            let offset = 0;

            while (offset < total && offset < MAX_TRACKS_TO_PROCESS) {
                updateStatus("Fetching playlist tracks...", 'text-white', 15 + (offset / Math.min(total, MAX_TRACKS_TO_PROCESS)) * 15, `Fetched ${offset} of ${total} tracks...`);

                const response = await fetchSpotify(url);
                total = response.total;
                
                response.items.forEach(item => {
                    // Note: Playlist tracks API returns { track: {...} } structure
                    if (item.track && item.track.id && item.track.artists.length > 0) {
                        tracks.push({
                            id: item.track.id,
                            uri: item.track.uri,
                            name: item.track.name,
                            artistId: item.track.artists[0].id
                        });
                    }
                });

                offset += response.items.length;
                url = response.next;
                
                if (!url || offset >= MAX_TRACKS_TO_PROCESS) {
                    break;
                }
            }

            updateStatus(`Fetched all tracks. Total: ${tracks.length}.`, 'text-white', 30);
            return tracks;
        }


        /** Fetches genres for a list of artist IDs. */
        async function fetchArtistGenres(artistIds) {
            const genreMap = {};
            const batches = [];
            
            // Batch artists into groups of 50 (API limit)
            for (let i = 0; i < artistIds.length; i += MAX_ARTISTS_PER_BATCH) {
                batches.push(artistIds.slice(i, i + MAX_ARTISTS_PER_BATCH));
            }

            for (let i = 0; i < batches.length; i++) {
                const batch = batches[i];
                const ids = batch.join(',');
                const url = `${API_BASE}/artists?ids=${ids}`;

                const percentage = 30 + ((i + 1) / batches.length) * 30;
                updateStatus("Analyzing song genres...", 'text-white', percentage, `Processing batch ${i + 1} of ${batches.length} artists...`);

                const response = await fetchSpotify(url);
                if (response.artists) {
                    response.artists.forEach(artist => {
                        if (artist && artist.id) {
                            genreMap[artist.id] = artist.genres || [];
                        }
                    });
                }
                await new Promise(resolve => setTimeout(resolve, 50)); 
            }

            return genreMap;
        }

        /** Creates a new public playlist with the provided name. */
        async function createPlaylist(playlistName, description) {
            const body = {
                name: playlistName, 
                description: description,
                public: true, 
            };

            const response = await fetchSpotify(`${API_BASE}/users/${userId}/playlists`, 'POST', body);
            return {
                id: response.id,
                url: response.external_urls.spotify,
                snapshot_id: response.snapshot_id
            };
        }

        /** Adds tracks to an existing playlist. */
        async function addTracksToPlaylist(playlistId, trackUris) {
            for (let i = 0; i < trackUris.length; i += MAX_TRACKS_PER_PLAYLIST_ADD) {
                const batch = trackUris.slice(i, i + MAX_TRACKS_PER_PLAYLIST_ADD);
                const body = { uris: batch };

                await fetchSpotify(`${API_BASE}/playlists/${playlistId}/tracks`, 'POST', body);
                await new Promise(resolve => setTimeout(resolve, 50)); 
            }
        }

        /** Main orchestration function. */
        async function startSortingProcess() {
            try {
                // Disable button during process
                document.getElementById('sortButton').disabled = true;

                // 1. Get User ID
                await getCurrentUser();

                // 2. Fetch Source Tracks
                const source = document.getElementById('sourceSelect').value;
                let tracks = [];
                let playlistTitle = "Liked Songs";

                if (source === 'liked_songs') {
                    tracks = await fetchAllLikedTracks();
                } else if (source === 'playlist') {
                    const input = document.getElementById('playlistInput').value;
                    const playlistId = extractIdFromUrl(input);

                    if (!playlistId) {
                        updateStatus("Error: Please enter a valid Playlist URL or ID.", 'text-red-400', 0);
                        return;
                    }
                    tracks = await fetchPlaylistTracks(playlistId);
                    
                    // Try to fetch playlist details to get a better title
                    try {
                        const playlistDetails = await fetchSpotify(`${API_BASE}/playlists/${playlistId}?fields=name`);
                        playlistTitle = playlistDetails.name;
                    } catch (e) {
                        console.warn("Could not fetch playlist name, using default.");
                    }
                }

                if (tracks.length === 0) {
                    updateStatus(`No tracks found in the selected source (${playlistTitle}).`, 'text-yellow-400', 100);
                    document.getElementById('sortButton').disabled = false;
                    return;
                }

                // 3. Get unique Artist IDs
                const uniqueArtistIds = Array.from(new Set(tracks.map(t => t.artistId))).filter(id => id);

                // 4. Fetch Genres for all Artists
                const artistGenreMap = await fetchArtistGenres(uniqueArtistIds);

                // 5. Sort Tracks by Broad Category ONLY
                // Structure: { 'CategoryName': [trackUris] } 
                const categoryTrackMap = {};
                const categories = Object.keys(GENRE_CATEGORY_MAP);
                
                // Initialize map with all required categories (to ensure all are present)
                categories.forEach(cat => { categoryTrackMap[cat] = []; });

                tracks.forEach(track => {
                    const genres = artistGenreMap[track.artistId] || ['pop']; // Use 'pop' as a safe default for artists with no genres
                    
                    let assignedCategory = null; 

                    // 1. Try explicit match for any of the artist's genres
                    for (const spotifyGenre of genres) {
                        assignedCategory = mapGenreToCategory(spotifyGenre);
                        if (assignedCategory) break; 
                    }

                    // 2. If no explicit match, try closest fit keyword matching
                    if (!assignedCategory) {
                        assignedCategory = findClosestCategory(genres);
                    }
                    
                    // Add the track to the corresponding category's list
                    if (!categoryTrackMap[assignedCategory].includes(track.uri)) {
                       categoryTrackMap[assignedCategory].push(track.uri);
                    }
                });

                // Filter out categories that ended up empty
                const activeCategories = Object.entries(categoryTrackMap).filter(([, uris]) => uris.length > 0);
                const estimatedTotalPlaylists = activeCategories.length;

                updateStatus(`Sorting complete. Found ${estimatedTotalPlaylists} categories to create playlists for.`, 'text-white', 65);

                // 6. Create Playlists and Add Tracks
                const playlistMap = {};
                let playlistCount = 0;

                for (const [category, trackUris] of activeCategories) {
                    playlistCount++;
                    
                    // New Playlist Name format: [CATEGORY] Sorter (from Source)
                    const newPlaylistName = `[${category.toUpperCase()}] Sorter (${playlistTitle})`;

                    const percentage = 65 + (playlistCount / estimatedTotalPlaylists) * 35;
                    updateStatus(
                        "Creating and populating playlists...", 
                        'text-white', 
                        percentage, 
                        `Processing Playlist: ${newPlaylistName} (${trackUris.length} tracks) - ${playlistCount}/${estimatedTotalPlaylists}`
                    );

                    // A. Create Playlist (Use category name as description)
                    const description = `Tracks categorized as ${category} from your ${playlistTitle}.`;
                    const newPlaylist = await createPlaylist(newPlaylistName, description);

                    // B. Add Tracks to Playlist
                    await addTracksToPlaylist(newPlaylist.id, trackUris);
                    
                    playlistMap[newPlaylistName] = {
                        url: newPlaylist.url,
                        trackUris: trackUris
                    };
                }

                updateStatus("‚úÖ All folders/playlists created and tracks added successfully!", 'text-spotifyGreen', 100, "Look for the new playlists in your Spotify library!");
                displayResults(playlistMap);

            } catch (error) {
                console.error("Critical Sorting Error:", error);
                if (document.getElementById('statusMessage').style.color !== 'red') {
                    updateStatus("A critical error occurred during the process. See console for details.", 'text-red-400', 100);
                }
            } finally {
                document.getElementById('sortButton').disabled = false;
            }
        }
        window.startSortingProcess = startSortingProcess; // Expose to global scope for onclick

        // --- INITIALIZATION AND ROUTER ---

        /** Main entry point to check for auth code and start process. */
        function initializeApp() {
            const params = new URLSearchParams(window.location.search);
            const code = params.get('code');

            if (accessToken) {
                // Should only happen if token was cached, but let's just show options.
                document.getElementById('optionsArea').classList.remove('hidden');
                updateStatus("Authentication successful! Ready to sort.", 'text-spotifyGreen', 10);
            } else if (code) {
                // Code received: hide link container and start auth flow
                document.getElementById('initialView').classList.add('hidden');
                document.getElementById('authLinkContainer').classList.add('hidden');
                document.getElementById('statusArea').classList.remove('hidden');
                
                // Remove code from URL and exchange it for a token
                window.history.pushState({}, document.title, REDIRECT_URI);
                exchangeCodeForToken(code);
            } else {
                // Show login button
                document.getElementById('loginButton').addEventListener('click', redirectToSpotifyAuth);
                document.getElementById('initialView').classList.remove('hidden');
            }
        }

        initializeApp(); // Start the application logic
    </script>
</body>
</html>
